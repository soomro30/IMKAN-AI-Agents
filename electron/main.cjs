const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const path = require('path');
const fs = require('fs');
const { spawn } = require('child_process');
const XLSX = require('xlsx');

let mainWindow;
let agentProcess = null;

app.setName('imkan-agents');

const APP_DATA_PATH = app.getPath('userData');
const DOWNLOADS_PATH = path.join(APP_DATA_PATH, 'Downloads');
const SETTINGS_FILE = path.join(APP_DATA_PATH, 'settings.json');

console.log('App data path:', APP_DATA_PATH);

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 900,
    minHeight: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload/preload.cjs'),
      contextIsolation: true,
      nodeIntegration: false,
    },
    icon: path.join(__dirname, 'assets/icon.png'),
    title: 'IMKAN Agents - Powered by SAAL.AI',
  });

  mainWindow.loadFile(path.join(__dirname, 'renderer/index.html'));

  mainWindow.on('closed', () => {
    if (agentProcess) {
      agentProcess.kill();
    }
    mainWindow = null;
  });
}

app.whenReady().then(() => {
  const envPath = ensureEnvFile();
  ensureDirectories();
  loadOrCreateSettings();
  createWindow();

  console.log('Environment file location:', envPath);
  console.log('Settings file location:', SETTINGS_FILE);
  console.log('Downloads location:', DOWNLOADS_PATH);

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (agentProcess) {
    agentProcess.kill();
  }
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

function ensureDirectories() {
  const dirs = [
    DOWNLOADS_PATH,
    path.join(DOWNLOADS_PATH, 'TitleDeeds'),
    path.join(DOWNLOADS_PATH, 'AffectionPlans'),
  ];

  dirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  });
}

function ensureEnvFile() {
  const envPath = path.join(APP_DATA_PATH, '.env');

  console.log('Checking for .env file at:', envPath);

  if (!fs.existsSync(envPath)) {
    console.log('Creating .env file with bundled credentials...');

    // Load credentials from local file (not committed to git)
    let credentials;
    try {
      credentials = require('./credentials.js');
      console.log('✓ Loaded credentials from credentials.js');
    } catch (error) {
      console.warn('⚠️  credentials.js not found, using placeholders');
      console.warn('   Copy credentials.example.js to credentials.js and add your API keys');
      credentials = {
        BROWSERBASE_API_KEY: 'your_browserbase_api_key_here',
        BROWSERBASE_PROJECT_ID: 'your_project_id_here',
        OPENAI_API_KEY: 'your_openai_api_key_here',
        TAMM_MOBILE_NUMBER: '971559419961',
      };
    }

    // Only include OPENAI_API_KEY if it's not empty (to use free Stagehand model)
    const openaiLine = credentials.OPENAI_API_KEY ? `OPENAI_API_KEY=${credentials.OPENAI_API_KEY}\n` : '';

    const envContent = `# IMKAN Agents - Auto-generated Configuration
# Do not edit this file manually - use the app settings instead

BROWSERBASE_API_KEY=${credentials.BROWSERBASE_API_KEY}
BROWSERBASE_PROJECT_ID=${credentials.BROWSERBASE_PROJECT_ID}
${openaiLine}TAMM_MOBILE_NUMBER=${credentials.TAMM_MOBILE_NUMBER}
`;

    try {
      fs.writeFileSync(envPath, envContent);
      console.log('✓ .env file created successfully');
    } catch (error) {
      console.error('Error creating .env file:', error);
    }
  } else {
    console.log('✓ .env file already exists');
  }

  return envPath;
}

function loadOrCreateSettings() {
  if (!fs.existsSync(SETTINGS_FILE)) {
    const defaultSettings = {
      general: {
        mobileNumber: '+971559419961',
      },
      titleDeed: {
        plotColumnIndex: 2,
        waitTimes: {
          captcha: 20000,
          uaePassTimeout: 180000,
        },
      },
      affectionPlan: {
        plotColumnIndex: 2,
        serviceName: 'Verification Certificate (Unit)',
        accountSwitching: {
          enabled: false,
          targetAccountName: 'Al Jurf Hospitality Service',
        },
        emailNotification: {
          enabled: false,
          recipientEmail: '',
        },
        waitTimes: {
          captcha: 20000,
          uaePassTimeout: 180000,
          downloadPageTimeout: 900000,
        },
      },
    };
    fs.writeFileSync(SETTINGS_FILE, JSON.stringify(defaultSettings, null, 2));
  }
}

ipcMain.handle('select-excel-file', async () => {
  const result = await dialog.showOpenDialog(mainWindow, {
    properties: ['openFile'],
    filters: [
      { name: 'Excel Files', extensions: ['xlsx', 'xls'] },
      { name: 'All Files', extensions: ['*'] },
    ],
  });

  if (!result.canceled && result.filePaths.length > 0) {
    return result.filePaths[0];
  }
  return null;
});

ipcMain.handle('get-settings', () => {
  try {
    const data = fs.readFileSync(SETTINGS_FILE, 'utf-8');
    return JSON.parse(data);
  } catch (error) {
    console.error('Error reading settings:', error);
    return null;
  }
});

ipcMain.handle('save-settings', (event, settings) => {
  try {
    fs.writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));
    return { success: true };
  } catch (error) {
    console.error('Error saving settings:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('run-agent', async (event, agentId, excelFilePath) => {
  if (agentProcess) {
    return { success: false, error: 'An agent is already running' };
  }

  try {
    console.log('Starting agent:', agentId);
    console.log('Excel file path:', excelFilePath);

    if (!fs.existsSync(excelFilePath)) {
      return { success: false, error: `Excel file not found: ${excelFilePath}` };
    }

    const settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, 'utf-8'));

    let agentSettings;
    let agentFolder;

    if (agentId === 'dari-title-deed') {
      agentSettings = settings.titleDeed;
      agentFolder = 'TitleDeeds';
    } else if (agentId === 'dari-affection-plan') {
      agentSettings = settings.affectionPlan;
      agentFolder = 'AffectionPlans';
    } else {
      return { success: false, error: `Unknown agent: ${agentId}` };
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
    const downloadDir = path.join(DOWNLOADS_PATH, agentFolder, timestamp);

    console.log('Download directory:', downloadDir);

    if (!fs.existsSync(downloadDir)) {
      fs.mkdirSync(downloadDir, { recursive: true });
    }

    const tempExcelPath = path.join(APP_DATA_PATH, 'temp-upload.xlsx');
    console.log('Copying Excel to:', tempExcelPath);
    fs.copyFileSync(excelFilePath, tempExcelPath);

    const configPath = path.join(APP_DATA_PATH, 'temp-config.json');
    const agentConfig = {
      ...agentSettings,
      excelFilePath: tempExcelPath,
      downloadPath: downloadDir,
      mobileNumber: settings.general?.mobileNumber || '+971559419961',
    };

    console.log('Agent config:', JSON.stringify(agentConfig, null, 2));
    fs.writeFileSync(configPath, JSON.stringify(agentConfig, null, 2));

    // Determine if we're in development or production (packaged)
    const isDev = !app.isPackaged;
    let agentScriptPath;

    if (isDev) {
      // Development: use local dist folder
      agentScriptPath = path.join(__dirname, '..', 'dist', 'index.js');
      console.log('Development mode - Agent script path:', agentScriptPath);
    } else {
      // Production: use app.asar.unpacked (files extracted from asar)
      agentScriptPath = path.join(process.resourcesPath, 'app.asar.unpacked', 'dist', 'index.js');
      console.log('Production mode - Agent script path:', agentScriptPath);
    }

    if (!fs.existsSync(agentScriptPath) && isDev) {
      return { success: false, error: `Agent script not found at ${agentScriptPath}. Run 'npm run build' first.` };
    }

    const envFilePath = path.join(APP_DATA_PATH, '.env');

    // Set working directory - use app data path in production for file access
    const workingDir = isDev ? path.join(__dirname, '..') : APP_DATA_PATH;
    console.log('Working directory:', workingDir);

    // Get the correct node executable path
    // In production, use Electron's bundled node, in dev use system node
    const nodePath = isDev
      ? 'node'  // Development: use system node from PATH
      : process.execPath;  // Production: use Electron's node (which is the Electron executable)

    console.log('Node executable:', nodePath);

    agentProcess = spawn(nodePath, [agentScriptPath, agentId], {
      env: {
        ...process.env,
        AGENT_CONFIG_PATH: configPath,
        DOWNLOAD_PATH: downloadDir,
        DOTENV_CONFIG_PATH: envFilePath,
        ELECTRON_RUN_AS_NODE: '1',  // Important: tells Electron to run as Node.js
      },
      cwd: workingDir,
    });

    console.log('Agent process spawned with PID:', agentProcess.pid);
    console.log('Agent script path:', agentScriptPath);
    console.log('Agent ID:', agentId);
    console.log('Config path:', configPath);
    console.log('Env file path:', envFilePath);

    // Send initial message to UI
    mainWindow.webContents.send('agent-output', `Starting ${agentId} agent...\n`);
    mainWindow.webContents.send('agent-output', `Script path: ${agentScriptPath}\n`);
    mainWindow.webContents.send('agent-output', `Working directory: ${workingDir}\n`);

    agentProcess.stdout.on('data', (data) => {
      const output = data.toString();
      console.log('Agent output:', output);
      mainWindow.webContents.send('agent-output', output);
    });

    agentProcess.stderr.on('data', (data) => {
      const error = data.toString();
      console.error('Agent error:', error);
      mainWindow.webContents.send('agent-output', `[ERROR] ${error}`);
      mainWindow.webContents.send('agent-error', error);
    });

    agentProcess.on('error', (err) => {
      console.error('Failed to start agent process:', err);
      const errorMsg = `Failed to start agent: ${err.message}`;
      mainWindow.webContents.send('agent-output', `[ERROR] ${errorMsg}\n`);
      mainWindow.webContents.send('agent-error', errorMsg);
      agentProcess = null;
    });

    agentProcess.on('close', (code) => {
      console.log('Agent process exited with code:', code);
      const success = code === 0;

      if (code !== 0) {
        mainWindow.webContents.send('agent-output', `\n[PROCESS EXITED] Code: ${code}\n`);
      }

      agentProcess = null;
      mainWindow.webContents.send('agent-finished', {
        code,
        success,
        downloadPath: downloadDir,
      });

      try {
        fs.unlinkSync(tempExcelPath);
        fs.unlinkSync(configPath);
      } catch (err) {
        console.error('Error cleaning up temp files:', err);
      }
    });

    return { success: true, downloadPath: downloadDir };
  } catch (error) {
    console.error('Error starting agent:', error);
    agentProcess = null;
    return { success: false, error: error.message };
  }
});

ipcMain.handle('stop-agent', () => {
  if (agentProcess) {
    agentProcess.kill();
    agentProcess = null;
    return { success: true };
  }
  return { success: false, error: 'No agent is running' };
});

ipcMain.handle('open-downloads', () => {
  require('electron').shell.openPath(DOWNLOADS_PATH);
});

ipcMain.handle('get-downloads-path', () => {
  return DOWNLOADS_PATH;
});

// Count plots in Excel file
ipcMain.handle('count-plots-in-excel', async (event, excelFilePath, plotColumnIndex) => {
  try {
    if (!fs.existsSync(excelFilePath)) {
      throw new Error('Excel file not found');
    }

    const workbook = XLSX.readFile(excelFilePath);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const data = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

    if (data.length === 0) {
      throw new Error('Excel file is empty');
    }

    // Count non-empty cells in the specified column (skip header row)
    let plotCount = 0;
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      if (row && row[plotColumnIndex]) {
        const plotNumber = String(row[plotColumnIndex]).trim();
        if (plotNumber) {
          plotCount++;
        }
      }
    }

    return { success: true, count: plotCount };
  } catch (error) {
    console.error('Error counting plots:', error);
    return { success: false, error: error.message };
  }
});
